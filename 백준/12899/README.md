# 12899번
<!-- tag 관련 기입 -->
`Fenwick Tree` , `Binary Indexed Tree`, `Segment Tree`

## 문제설명
```
문제
자연수를 저장하는 데이터베이스 S에 대해 다음의 쿼리를 처리합시다.
유형 1 : S에 자연수 X를 추가한다.
유형 2 : S에 포함된 숫자 중 X번째로 작은 수를 응답하고 그 수를 삭제한다.

Input
첫째 줄에 사전에 있는 쿼리의 수 N 이 주어집니다. (1 ≤ N ≤ 2,000,000)
둘째 줄부터 N개의 줄에 걸쳐 각 쿼리를 나타내는 2개의 정수 T X가 주어집니다.
T가 1이라면 S에 추가할 X가 주어지는 것입니다. (1 ≤ X ≤ 2,000,000)
T가 2라면 X는 S에서 삭제해야 할 몇 번째로 작은 수인지를 나타냅니다. S에 최소 X개의 원소가 있음이 보장됩니다.
Output
유형 2의 쿼리 개수만큼의 줄에 각 쿼리에 대한 답을 출력합니다.
```
### 접근 설명

**사실 이 문제는 팬윅 트리로 푸는 문제이나 나는 정석 세그먼트 트리로 풀었다. 추후 팬윅트리 풀이 업로드 필요**
X의 값이 <= 2,000,000 이므로 세그먼트트리 사이즈를 2,000,000으로 잡아, 인덱스 카운팅을 한다. ex) a[3] = 2 -> 자연수 3이 2개 존재한다.
2,000,000 개의 leaf 노드를 둔 세그먼트 트리를 형성한다.
유형 1 : 해당 노드의 값을 1증가시키고, 세그먼트 트리를 업데이트 한다.
유형 2 : lower_bound, x 번째와 같거나 큰 세그먼트 트리의 부분합의 범위(l = 0 고정, r을 찾음)를 찾는다. 찾은 r은 순서에 맞는 자연수를 뜻한다.
ex) r = 4 -> 자연수 4 하나를 없애야 한다. 해당 노드의 값을 1 감소시키고, 세그먼트 트리를 업데이트 한다.

ex) 1 2 2 3 4 5 -> 2번째 원소를 찾으면, 2이다. query [1, 2] -> 3이므로 lower_bound 에 적합함.
## 풀이설명
세그먼트 트리구조이기에, 세그먼트 트리를 형성했고 `유형 2` 연산을 위해 이분탐색 lower_bound 를 구현하여 풀었다.
기본 자료구조, segment leaf -> ex) `seg[n + 0] = 3 -> 자연수 1은 3개 있다.` `n + 0`: segment tree를 완전 이진 트리로 구성하지 않고,  0부터 leaf 노드 시작했기에 0번이 -> 자연수 1을 의미한다.
`int find_xnum(int x)` : x 번째에 위치한 자연수를 찾는 함수
`update(int i, int val)` : 자연수 i의 개수를 val 만큼 더함
`query(int l, inr)` : `[l, r)` 의 부분합 