# 16975번
<!-- tag 관련 기입 -->
`Segment Tree` , `Data structure`

## 문제설명
길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.

`1 i j k`: Ai, Ai+1, ..., Aj에 k를 더한다.
`2 x`: Ax 를 출력한다.

### 접근
원소를 업데이트하고, 구간합을 구하는 기존의 세그먼트 문제와 다르게, 구간에 값을 업데이트하고 쿼리를 달리면 해당 원소의 값을 트리를 따라 올라가면서 구하는 방식이다.
ex) 각 트리의 원소는 각 구간의 부여된 더하기 연산이다.즉 루트 노드의 값이 5면, `1~8`까지의 원소에 5를 더한 값이다. 1번 연산을 세그먼트 트리로 효율적으로 표현한다. 내가 만약 5번 원소의 값을 구하고 싶으면, 5번 원소의 값 + `5~6`범위의 값 + `5~8` 범위값 + `1~8` 범위값을 모두 더한다.
이를 만족하기 위해선, 1번 연산을 했을 때 겹치면 안된다. 가장 큰 범위부터 업데이트를 해야한다. ex) 1~6 범위 연산이면 [1,2], [3,4], [5,6] 을 업데이트 하지 않고,
[1,2,3,4], [5,6] 을 업데이트 한다.
```
                  [1, 2, 3, 4, 5, 6, 7, 8]
                            | 
                   --------------------- 
                   |                   |
             [1,2,3,4]            [5,6,7,8] 
                |                      | 
         --------------          -------------- 
         |            |          |            | 
      [1,2]         [3,4]       [5,6]        [7,8]
        |               |          |            | 
   -----------      -----------  ----------  ----------
   |         |      |         |  |        |  |        |
  [1]       [2]    [3]       [4] [5]      [6] [7]      [8]
```

## 풀이설명
먼저, leaf 노드 시작점을 찾는다. 완전 이진 트리로 구축해야 하기에, 2의 거듭제곱으로 찾는다.
` while((bound <<= 1) < n);` 
n과 같거나, 큰 bound를 찾는다면 leaf 노드에 배열의 원소를 모두 담을 수 있다.
또한, leaf 노드를 제외한 트리의 모든 노드들의 개수는 bound - 1 과 같으므로, bound 부터 배열의 원소를 담으면 된다.
`query function`
쿼리 함수는 해당 leaf 부터 루트까지 거치면서 자신의 범위에 더해진 숫자값(`1번 연산`)을 순차적으로 다 더하면 된다.
`update function`
업데이트 함수는 `2번 연산` 에 대한 것이다. 해당 범위에 완벽히 들어맞는 노드에 값을 더한다.
ex)`[1,6]` -> `[1,2,3,4]` and `[5,6]` 에 위치하는 노드의 값을 업데이트 해야한다.
그래야, 원소의 값을 추적할 때 부모노드로 올라오면서 값을 더해가는 방식으로 구현할 수 있기 때문이다.