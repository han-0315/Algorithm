# 1517번
<!-- tag 관련 기입 -->
`segment tree` , `merge sort`
## 문제설명
N개의 수로 이루어진 수열 A[1], A[2], …, A[N]이 있다. 이 수열에 대해서 버블 소트를 수행할 때, Swap이 총 몇 번 발생하는지 알아내는 프로그램을 작성하시오.

### 접근
각 원소 숫자들에 의해 몇번에 swap이 일어났는 지 계산하고, 이를 더한다. 
ex) 5,4,1,3,2
각 원소에 의해 일어난 swap을 아래에 차례대로 작성하면 
`5 -> 4번, 4 -> 3번, 3 -> 1번, 2 -> 0번, 1 -> 0번`
이를 유추하면 자신보다 오른쪽에 있는 원소중 값이 작은 원소들의 개수라는 것을 알 수 있다. 
큰 값을 순서대로 찾고 자신의 오른쪽에 위치한 원소 중 작은 값을 계속찾는다면 O(n^2) 이므로, 이를 `O(nlogn)` 으로 해결하기 위해 아래의 2가지 방법을 사용한다.
## 풀이설명
### 1. Merge sort 변형
merge sort 중 두 노드를 합치는 과정에서 ex) `[2,3],[1,4],[5,6], [7,8]` 에서 `[2,3] , [1,4]` 를 합칠 때, 오른쪽의 있는 값들 중에, 자신보다 작은 값들이 몇개 있는 지, 왼쪽에 있는 값들 중에 오른쪽 노드 원소보다 큰 원소가 몇개 있는 지 확인하면서 swap의 개수를 파악한다.

### 2. 세그먼트 트리 이용
`idx 0 1 2 3 4 5`
`val 6 4 3 5 2 1`
효율적인 탐색을 위해 처음 인덱스를 기억하고, 값으로 정렬한 뒤 작은 값부터 시작한다. 자신의 오른쪽에 몇개의 원소가 있는지(=자기보다 작은 것)이 몇개 있는지 확인하고 이를 더한다.

버블정렬을 (오름차순) 왼쪽에서 오른쪽 방향으로 진행한다 가정하면, 가장 작은 원소 1의 이동 횟수는 당연히 0임 2의 이동횟수는 내 앞에 1이 있느냐가 중요하고, 3 또한 앞에 1,2가 있는가에 의해 swap이 일어남.
그렇다면, 이를 추적하는 방법은 배열을 (val, idx)로 저장한 뒤, val 을 기준으로 정렬을 시킴
배열은 오름차순으로 정렬되고, 이제 우리는 1부터 index를 통해 확인하면 됨 1의 앞에는 존재하는 원소가 없음 -> 원래 위치인 5로 이동 다음 2는 index가 4임 그러므로 4~5사이의 존재하는 원소의 누적합 -> +1, 3 또한 같은 과정으로 `2~5`사이의 누적합 -> 2 4도 같은 과정으로 `1~5`사이의 누적합 +3, 5는 `3~5`사이의 누적합 2 이런식으로 구함

