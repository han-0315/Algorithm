
### 문제설명


666은 종말을 나타내는 수라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다. 하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.


종말의 수란 어떤 수에 6이 적어도 3개 이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 수는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 이다. 따라서, 숌은 첫 번째 영화의 제목은 "세상의 종말 666", 두 번째 영화의 제목은 "세상의 종말 1666"와 같이 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 수) 와 같다.


숌이 만든 N번째 영화의 제목에 들어간 수를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.


> 💡 여기서 N은 10,000 보다 작으므로 간단하게 1~10,000의 수를 모두 조사한 뒤 종말의 수 집합을 찾고 정렬시키면 구할 수 있다.   
> 하지만, N이 적당히 큰 수라면 예를 들어 10^18 정도 되는 수라면 어떻게 찾을 수 있을까?


```c++
// 이 부분 중 마지막         f[i][0]=9*(f[i-1][0]+f[i-1][1]+f[i-1][2]);  수식이 이해가 안감
// 길이가 i 중 상위 0 자리 = 맨앞이 6만 아니면 된다. 0 ~ 9 중 6을 제외한 9가지의 경우
for(int i=1;i<=20;i++){
        f[i][3]=f[i-1][2]+10*f[i-1][3];
        f[i][2]=f[i-1][1];
        f[i][1]=f[i-1][0];
        f[i][0]=9*(f[i-1][0]+f[i-1][1]+f[i-1][2]); 
    }
```


### 분석


> 💡 시간복잡도 계산  
> 


### 해결과정


> 💡 아이디어  
> 여기서 “~”는 나머지 숫자를 의미한다. 즉 5666~이면 5666으로 시작하는 종말의 수를 의미한다.  
>   
> 만약 100번째 종말의 수가 궁금하다면, 종말의 수의 상위 첫번째 수부터 결정한다.   
>   
> 아이디어는 다음과 같다. 우선 상위 1자리의 수를 결정한다. 이것은 1부터 시작해서 계속 연산하면 되는데 만약 첫번째 수가 5라면, 4666~ < 100 ≤ 5666~  일것이다.   
>   
> > 반대도 성립하나? 4666~ < 100 ≤ 5666~라고해서 첫번째 수가 5가 되는 것이 맞나?     
> > 이를 증명하려면, $9(f[n-1][3] + ... +f[3][3]) < f[n][3]$ 이 맞다는 것을 확인하면 된다. 이는 처음의 관계식의 조건 $f[i][3]=f[i-1][2]+10*f[i-1][3]$ 에 의해 참이된다. 왜냐면 단순하게, f[n][3]이 f[n-1][3]*10보다 크니, 이를 빼면 f[n-1][3] 이 또 남을 것이고 이는 그 다음의 수 f[n-2][3]을 소거시켜준다. 우리는 중간의 f[i-1][2]가 계속 쌓이므로 클 수 밖에 없다.   
>   
> 그렇기에 상위 자리수를 하나씩 결정할 수 있고, 이 자리수가 모두 결정이 되면 문제를 해결할 수 있다.


	여기서 “~”는 나머지 숫자를 의미한다. 즉 5666~이면 5666으로 시작하는 종말의 수를 의미한다.


	만약 100번째 종말의 수가 궁금하다면, 종말의 수의 상위 첫번째 수부터 결정한다. 


	아이디어는 다음과 같다. 우선 상위 1자리의 수를 결정한다. 이것은 1부터 시작해서 계속 연산하면 되는데 만약 첫번째 수가 5라면, 4666~ < 100 ≤ 5666~  일것이다. 


	> 반대도 성립하나? 4666~ < 100 ≤ 5666~라고해서 첫번째 수가 5가 되는 것이 맞나?   
	> 이를 증명하려면, $9(f[n-1][3] + ... +f[3][3]) < f[n][3]$ 이 맞다는 것을 확인하면 된다. 이는 처음의 관계식의 조건 $f[i][3]=f[i-1][2]+10*f[i-1][3]$ 에 의해 참이된다. 왜냐면 단순하게, f[n][3]이 f[n-1][3]*10보다 크니, 이를 빼면 f[n-1][3] 이 또 남을 것이고 이는 그 다음의 수 f[n-2][3]을 소거시켜준다. 우리는 중간의 f[i-1][2]가 계속 쌓이므로 클 수 밖에 없다. 


	그렇기에 상위 자리수를 하나씩 결정할 수 있고, 이 자리수가 모두 결정이 되면 문제를 해결할 수 있다. 


> 💡 응용  
> 해당 문제는 특정 문자열(연속된 숫자)가 포함된 경우를 따진다. 만약 55가 있는 정수의 개수 등에 응용할 수 있다. 연속된 수이기에 더 어려운 문제이다. 12과 같은 경우는 같은 방식으로 상위 0, 1자리가 같지만 포함되지 않은 숫자, 상위 2자리가 같은 경우 (12) 포함되는 숫자 이런 식으로 더해가면 된다.  
> b[i][0] = 9 * (b[i-1][0] + b[i-1][1])  
> b[i][1] = b[i-1][0]  
> b[i][2] = b[i-1][1] + b[i-1][2]


> 💡 응용2  
> 해당 문제를 변환해서 어떤 종말의 수 ex) 52666를 입력하면 몇번째 종말의 수인지 알아맞춰야 한다고 하자. 이 문제는 다음과 같이 해결할 수 있다. 50000이하의 종말의 수 + 2000이하의 종말의 수 + 1(666이므로), 10000미만의 종말의 수는 (10000 - f[4][0] + f[4][1] + f[4][2]) *5 = 19 * 5이다. 여기서 2000이하의 종말의 수 = 2 , 즉 95 + 2 + 1 = 98번째 수이다.  
> 예시를 하나 더 들어서 56662는 몇번째 종말의 수인지 구해보자. 50000이하의 종말의 수 + 6000이하의 종말의 수 + 0(666아님)이다. 즉 95 + 1 * 6 + 0= 101  
> 


### 소스코드


```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN=22;
 
long long f[MAXN][4];
 
void prework(){
    f[0][0]=1;
    for(int i=1;i<=20;i++){
        f[i][3]=f[i-1][2]+10*f[i-1][3];
        f[i][2]=f[i-1][1];
        f[i][1]=f[i-1][0];
        f[i][0]=9*(f[i-1][0]+f[i-1][1]+f[i-1][2]); 
    }
}

int main()
{
	// 디버깅용
	freopen("input.txt", "r", stdin);
	int n, t;
	prework();
    cin>>t;
    while(t--){
        cin>>n;
        int len=3;
        while(f[len][3]<n) len++;
        int k=0;
        for(int i=len;i;i--){
            for(int j=0;j<=9;j++){
                long long cnt=f[i-1][3];
				// 현재까지 6의 개수를 확인 K는 현재까지 연속된 6의 개수
				// 만약 앞이 6이라면, 종말의 수를 더하는 것은 f[i-1][2] 만 하면된다. 
				// k(연속된 6의 개수)가 2라면, j도 6이라면 뒤에 어떤 수가 와도 되니 f[i-1][0~3]를 더한다. f[i-1][3]은 위에 카운트의 초기값이기에, 아래에서는 더하지 않음
				// 즉 k + j의 개수가 3이라면 f[i-1][0~3], 2라면 f[i-1][1~3], 1이라면 f[i-1][2~3] 0이라면 f[i-1][3]만 더하는 것이다.
                if(j==6||k==3){
                    for(int l=max(3-k-(j==6),0);l<3;l++){
                        cnt+=f[i-1][l];
                    }
                }
                if(cnt<n) n-=cnt;
                else{
                    if(k<3){
                        if(j==6) k++;
                        else k=0;
                    }
                    cout<<j;
                    break;
                }
            }
        }
        cout<<endl;
 
    }
    return 0;
}
```


### 배운점


> 💡 쉬운 문제도 하드하게 입력값의 범위를 넓히면, N을 키우면 정말 어려워진다는 것을 다시한번 느꼈다. 또한, 숫자를 문자열로 생각하고 앞자리[상위 첫번째 자리]부터 해결한다는 아이디어도 떠올려야 한다.

