# 번
<!-- tag 관련 기입 -->
`Segment Tree` , `요세푸스`

## 문제설명

```markdown
요세푸스 문제는 다음과 같다.

1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.

N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.
```
**입력**
`첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 100,000)`

### 접근방법
기존의 문제에서는 구간합에 대한 쿼리를 날렸지만 이 문제에서는 합에 대한 정보를 미리 알려주고, 범위를 구하는 것이다.
ex:  
- 다른 문제 : 1~3의 합을 구해라
- 이번 문제 : 합이 5인 구간은?

먼저, N개의 노드를 leaf로 둔 세그먼트 트리를 형성하고, 초기값은 1로 둔다. 자연스럽게`Root = N개의 노드들의 합` 이 된다. 우리는 K번째의 숫자를 계속 제거한다. 제거되는 원소를 잘 살펴보면 아래의 예시는 문제에서 준 (7,3)의 예시이다. 
`1 2 3 4 5 6 7` 아래는 삭제되는 원소이다.
- 3 : 구간합 3 : sum = 3 
- 6 : 구간합 5 : sum = 3 + 2 
- 2 : 구간합 2 : sum = 3 + 2 + 2 -> sum % size = 2
이렇게, 구간합에 대한 정보를 우리는 얻을 수 있다.
만약 현재의 집합의 크기 = `Root` 보다 k가 커지면, 사이즈만큼 나누면 된다.
sum (찾을 구간 합)의 값에 `k`가 아니라 `K-1`을 더하는 이유는, 2번째를 생각하면 편하다. 3의 노드가 제거되었기에, 우리는 합이 6번째를 찾는 것이 아닌 5번째를 찾아야한다. 6번째는 7을 가리킨다.
상황 : `1 2 4 5 6 7`
## 풀이설명
완전이진트리로 구성했다. 이번 문제는 블로그 자료를 많이 참고했는데, 다른 사람의 아이디어는 사뭇다르다.
```cpp
void init(int n){
    int len = 1;
    while((len <<= 1) < n);
    for(int i = 0; i<n;i++) seg[len + i] = 1;
    for(int i = len-1; i>0; i--) seg[i] = seg[i << 1] + seg[i << 1 | 1];
}
```
아래에서는 완전 이진트리가 아니라 이진트리만 유지한 상태이다. 
```cpp
int init(int node, int s, int e) {
    if (s == e) return seg[node] = 1;
    int mid = (s + e) >> 1;
    return seg[node] = init(2 * node, s, mid) + init(2 * node + 1, mid + 1, e);
}
```
두개는 다음과 같은 차이점이 있다. ex) `size = 5`
첫번째 코드는 완전 이진 트리 형태이지만 두번째 트리는 아래와 같다.
```css
                  [1, 2, 3, 4, 5]
                       /    \
             [1, 2, 3]      [4, 5]
               /   \         /   \
           [1, 2] [3]     [4]   [5]
            /   \
          [1]   [2]
```
#### query
맞는 위치의 원소를 찾는다.(위에서 아래로)
```cpp
int qeury(int node, int s, int e, int num){
    seg[node]--;
    int m = (s + e)/2;
    if(s==e) return s;

    if(seg[node << 1] >= num) return qeury(node << 1, s, m, num);
    else return qeury(node << 1 | 1, m+1, e, num - seg[node << 1]);
}
```
  